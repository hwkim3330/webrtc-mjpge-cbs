<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Watch - MJPEG Stream</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
      background: #f5f5f7;
      min-height: 100vh;
      color: #1d1d1f;
      padding: 20px;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      max-width: 1800px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 { font-size: 1.5rem; font-weight: 600; }
    .back-btn {
      padding: 8px 16px;
      background: #fff;
      color: #0071e3;
      text-decoration: none;
      border-radius: 980px;
      font-size: 0.85rem;
      border: 1px solid #d2d2d7;
    }
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      max-width: 1800px;
      margin: 0 auto;
    }
    @media (max-width: 1200px) {
      .main-grid { grid-template-columns: 1fr; }
    }
    .panel {
      background: #fff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.06);
    }
    .panel h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 16px;
      color: #1d1d1f;
    }
    .stream-container {
      position: relative;
      width: 100%;
      min-height: 360px;
      background: #1d1d1f;
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stream-container img {
      width: 100%;
      height: auto;
      display: block;
    }
    .no-stream {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #86868b;
      padding: 40px;
    }
    .no-stream svg { width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.4; }
    .no-stream p { font-size: 0.9rem; }
    .status {
      padding: 10px;
      border-radius: 10px;
      text-align: center;
      font-weight: 500;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }
    .status.waiting { background: #f5f5f7; color: #86868b; }
    .status.connected { background: rgba(52,199,89,0.1); color: #34c759; }
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    .chart-box {
      background: #f5f5f7;
      border-radius: 12px;
      padding: 12px;
    }
    .chart-box h3 {
      font-size: 0.7rem;
      color: #86868b;
      margin-bottom: 6px;
      font-weight: 500;
    }
    .chart-wrapper { height: 80px; }
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid #f5f5f7;
      font-size: 0.85rem;
    }
    .stat-row:last-child { border-bottom: none; }
    .stat-label { color: #86868b; }
    .stat-value { font-weight: 600; color: #0071e3; }
    .stat-value.warning { color: #ff9500; }
    .stat-value.danger { color: #ff3b30; }
    .stat-value.good { color: #34c759; }
    .direct-url {
      margin-top: 16px;
      padding: 12px;
      background: #f5f5f7;
      border-radius: 10px;
      font-size: 0.8rem;
    }
    .direct-url label { color: #86868b; display: block; margin-bottom: 4px; }
    .direct-url code { color: #0071e3; word-break: break-all; font-size: 0.75rem; }
    .codec-badge {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(0,113,227,0.1);
      color: #0071e3;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Viewer <span class="codec-badge">MJPEG</span></h1>
    <a href="/" class="back-btn">Back</a>
  </div>

  <div class="main-grid">
    <div class="panel">
      <h2>Live Stream</h2>
      <div class="stream-container">
        <img id="streamImg" alt="Stream" style="display:none;">
        <div id="noStream" class="no-stream">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
          </svg>
          <p>Waiting for broadcaster...</p>
        </div>
      </div>
      <div class="direct-url">
        <label>Direct Stream URL</label>
        <code id="streamUrl"></code>
      </div>
    </div>

    <div class="panel">
      <div id="status" class="status waiting">Waiting</div>
      <h2>Live Stats</h2>
      <div class="charts-grid">
        <div class="chart-box">
          <h3>Bitrate (Mbps)</h3>
          <div class="chart-wrapper"><canvas id="bitrateChart"></canvas></div>
        </div>
        <div class="chart-box">
          <h3>Frame Rate (fps)</h3>
          <div class="chart-wrapper"><canvas id="fpsChart"></canvas></div>
        </div>
        <div class="chart-box">
          <h3>E2E Latency (ms)</h3>
          <div class="chart-wrapper"><canvas id="latencyChart"></canvas></div>
        </div>
        <div class="chart-box">
          <h3>Network RTT (ms)</h3>
          <div class="chart-wrapper"><canvas id="rttChart"></canvas></div>
        </div>
        <div class="chart-box">
          <h3>Dropped Frames</h3>
          <div class="chart-wrapper"><canvas id="lossChart"></canvas></div>
        </div>
        <div class="chart-box">
          <h3>Frame Size (KB)</h3>
          <div class="chart-wrapper"><canvas id="frameSizeChart"></canvas></div>
        </div>
      </div>
      <div style="margin-top:16px;">
        <div class="stat-row"><span class="stat-label">Current Bitrate</span><span class="stat-value" id="bitrate">-</span></div>
        <div class="stat-row"><span class="stat-label">Current FPS</span><span class="stat-value" id="fps">-</span></div>
        <div class="stat-row"><span class="stat-label">E2E Latency</span><span class="stat-value" id="latency">-</span></div>
        <div class="stat-row"><span class="stat-label">Network RTT</span><span class="stat-value" id="rtt">-</span></div>
        <div class="stat-row"><span class="stat-label">Packet Loss</span><span class="stat-value" id="packetLoss">0%</span></div>
        <div class="stat-row"><span class="stat-label">Frames Dropped</span><span class="stat-value" id="framesLost">0</span></div>
        <div class="stat-row"><span class="stat-label">Frame Size</span><span class="stat-value" id="frameSize">-</span></div>
        <div class="stat-row"><span class="stat-label">Frames Received</span><span class="stat-value" id="framesReceived">-</span></div>
        <div class="stat-row"><span class="stat-label">Total Received</span><span class="stat-value" id="bytesReceived">-</span></div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const streamImg = document.getElementById('streamImg');
    const noStreamEl = document.getElementById('noStream');
    const statusEl = document.getElementById('status');

    document.getElementById('streamUrl').textContent = location.origin + '/stream.mjpg';

    const MAX_POINTS = 60;
    const statsData = { bitrate: [], fps: [], latency: [], rtt: [], loss: [], frameSize: [], labels: [] };

    const chartOpts = {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      scales: {
        x: { display: false },
        y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' }, ticks: { font: { size: 8 }, color: '#86868b' } }
      },
      plugins: { legend: { display: false } },
      elements: { point: { radius: 0 }, line: { tension: 0.3, borderWidth: 2 } }
    };

    function makeChart(id, color) {
      return new Chart(document.getElementById(id), {
        type: 'line',
        data: { labels: [], datasets: [{ data: [], borderColor: color, backgroundColor: color + '20', fill: true }] },
        options: chartOpts
      });
    }

    const charts = {
      bitrate: makeChart('bitrateChart', '#0071e3'),
      fps: makeChart('fpsChart', '#34c759'),
      latency: makeChart('latencyChart', '#ff9500'),
      rtt: makeChart('rttChart', '#5856d6'),
      loss: makeChart('lossChart', '#ff3b30'),
      frameSize: makeChart('frameSizeChart', '#af52de')
    };

    function updateCharts() {
      Object.keys(charts).forEach(key => {
        if (statsData[key]) {
          charts[key].data.labels = statsData.labels;
          charts[key].data.datasets[0].data = statsData[key];
          charts[key].update('none');
        }
      });
    }

    // 변수 먼저 선언
    let lastFrameTime = Date.now();
    let pollingMode = false;
    let pollingInterval = null;
    let mjpegFailCount = 0;
    let streamStarted = false;
    let myViewerId = null;  // 서버에서 할당받은 뷰어 ID

    socket.emit('viewer');

    // 서버에서 뷰어 ID 수신
    socket.on('viewer-id', (id) => {
      myViewerId = id;
      console.log('Received viewer ID:', myViewerId);
      // 이미 스트림 시작했으면 재연결
      if (streamStarted && !pollingMode) {
        const url = '/stream.mjpg?id=' + myViewerId + '&t=' + Date.now();
        streamImg.src = url;
        // MJPEG 연결 알림
        socket.emit('mjpeg-connected', { viewerId: myViewerId });
      }
    });

    // 페이지 로드 후 3초 안에 스트림 안 시작되면 강제 시작
    setTimeout(() => {
      if (!streamStarted) {
        console.log('Force starting stream...');
        startStream();
      }
    }, 3000);

    // RTT 측정
    let serverRtt = 0;
    let clockOffset = 0; // 서버와 클라이언트 시계 차이

    function measureRtt() {
      const startTime = Date.now();
      socket.emit('ping-measure', { clientTime: startTime });
    }

    socket.on('pong-measure', (data) => {
      const now = Date.now();
      serverRtt = now - data.clientTime;
      // 서버 시계와 클라이언트 시계 차이 추정 (NTP 방식)
      clockOffset = data.serverTime - data.clientTime - (serverRtt / 2);

      // RTT 표시 및 색상
      const rttEl = document.getElementById('rtt');
      rttEl.textContent = serverRtt + ' ms';
      rttEl.classList.remove('good', 'warning', 'danger');
      if (serverRtt <= 20) rttEl.classList.add('good');
      else if (serverRtt <= 50) rttEl.classList.add('warning');
      else rttEl.classList.add('danger');

      // RTT 차트 데이터 추가
      statsData.rtt.push(serverRtt);
      if (statsData.rtt.length > MAX_POINTS) statsData.rtt.shift();
    });

    // 1초마다 RTT 측정
    setInterval(measureRtt, 1000);
    measureRtt(); // 초기 측정

    socket.on('broadcaster-status', (broadcasting) => {
      console.log('broadcaster-status:', broadcasting);
      if (broadcasting) {
        // 스트림 시작
        startStream();
      } else {
        stopStream();
      }
    });

    // 연결되면 바로 상태 다시 요청
    socket.on('connect', () => {
      console.log('Socket connected, requesting status...');
      socket.emit('viewer');
    });

    // Polling 모드 (Safari/맥북 fallback) - 변수는 위에서 선언됨

    function startStream() {
      streamStarted = true;
      console.log('startStream called, pollingMode:', pollingMode, 'viewerId:', myViewerId);

      if (pollingMode) {
        startPolling();
      } else {
        // MJPEG 모드 시도 (viewerId 포함)
        const url = '/stream.mjpg?id=' + (myViewerId || '') + '&t=' + Date.now();
        console.log('Loading MJPEG:', url);
        streamImg.src = url;
      }
      streamImg.style.display = 'block';
      noStreamEl.style.display = 'none';
      statusEl.textContent = 'Connected';
      statusEl.className = 'status connected';
      lastFrameTime = Date.now();
    }

    function startPolling() {
      if (pollingInterval) clearInterval(pollingInterval);
      console.log('Polling mode activated');
      statusEl.textContent = 'Connected (Polling)';

      function fetchFrame() {
        streamImg.src = '/frame.jpg?' + Date.now();
      }
      fetchFrame();
      pollingInterval = setInterval(fetchFrame, 66); // ~15fps
    }

    function stopStream() {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      streamImg.src = '';
      streamImg.style.display = 'none';
      noStreamEl.style.display = 'flex';
      statusEl.textContent = 'Waiting';
      statusEl.className = 'status waiting';
    }

    let reconnectTimer = null;

    streamImg.onload = () => {
      lastFrameTime = Date.now();
      mjpegFailCount = 0; // 성공하면 리셋
      // MJPEG 연결 성공 시 서버에 알림
      if (myViewerId && !pollingMode) {
        socket.emit('mjpeg-connected', { viewerId: myViewerId });
      }
    };

    streamImg.onerror = () => {
      mjpegFailCount++;
      console.log('Stream error, count:', mjpegFailCount);

      // MJPEG 3번 실패하면 polling 모드로 전환
      if (!pollingMode && mjpegFailCount >= 3) {
        console.log('Switching to polling mode');
        pollingMode = true;
        startPolling();
        return;
      }

      statusEl.textContent = 'Reconnecting...';
      statusEl.className = 'status waiting';
      setTimeout(() => {
        startStream();
      }, 1000);
    };

    // 5초 동안 프레임 없으면 polling 모드 시도
    setInterval(() => {
      const elapsed = Date.now() - lastFrameTime;
      if (elapsed > 5000 && streamImg.style.display === 'block' && !pollingMode) {
        console.log('No frames for 5s, switching to polling mode...');
        pollingMode = true;
        startPolling();
      }
    }, 3000);

    let totalFrames = 0;
    let totalBytes = 0;

    // Real-time frame stats from server
    let lastSocketTime = Date.now();
    let socketLatency = 0;

    // 비트레이트 계산용
    let bitrateBytes = 0;
    let lastBitrateTime = Date.now();
    let currentBitrate = 0;

    // FPS 비교용 (색상 표시)
    let expectedFps = 15; // 기본값, broadcaster에서 받아옴

    // 상태에 따른 색상 업데이트 함수
    function updateStatusColor(elementId, value, thresholds) {
      const el = document.getElementById(elementId);
      el.classList.remove('good', 'warning', 'danger');
      if (value <= thresholds.good) {
        el.classList.add('good');
      } else if (value <= thresholds.warning) {
        el.classList.add('warning');
      } else {
        el.classList.add('danger');
      }
    }

    function updateFpsStatusColor(elementId, value, targetFps) {
      const el = document.getElementById(elementId);
      el.classList.remove('good', 'warning', 'danger');
      const ratio = value / targetFps;
      if (ratio >= 0.9) {
        el.classList.add('good');
      } else if (ratio >= 0.7) {
        el.classList.add('warning');
      } else {
        el.classList.add('danger');
      }
    }

    // 차트 색상 동적 업데이트
    function updateChartColor(chart, value, thresholds, invertColors = false) {
      let color;
      if (invertColors) {
        // 낮을수록 좋음 (latency, loss)
        if (value <= thresholds.good) color = '#34c759';
        else if (value <= thresholds.warning) color = '#ff9500';
        else color = '#ff3b30';
      } else {
        // 높을수록 좋음 (fps)
        if (value >= thresholds.good) color = '#34c759';
        else if (value >= thresholds.warning) color = '#ff9500';
        else color = '#ff3b30';
      }
      chart.data.datasets[0].borderColor = color;
      chart.data.datasets[0].backgroundColor = color + '20';
    }

    // 패킷 로스 계산용 (서버에서 받은 myDropped/mySent 사용)
    let myDropped = 0;
    let mySent = 0;
    let lastMyDropped = 0;
    let lossHistory = [];
    const LOSS_HISTORY_SIZE = 10; // 최근 10개 샘플 평균

    // 개별 뷰어 stats 수신 (MJPEG 연결 후)
    socket.on('frame-stats', (data) => {
      const now = Date.now();
      const interval = now - lastSocketTime;
      lastSocketTime = now;
      lastFrameTime = now; // 프레임 수신 시간 업데이트 (자동 재연결용)

      // 서버에서 보낸 개별 드랍/전송 정보 사용
      if (data.myDropped !== undefined) {
        myDropped = data.myDropped;
        mySent = data.mySent || 0;
      }

      // 이번 구간 드랍 수
      const droppedThisCycle = myDropped - lastMyDropped;
      lastMyDropped = myDropped;

      // 로스율 계산 (드랍 / (드랍 + 전송))
      const totalAttempted = myDropped + mySent;
      let lossRate = totalAttempted > 0 ? (myDropped / totalAttempted) * 100 : 0;

      // 최근 드랍 기록 (그래프용)
      lossHistory.push(droppedThisCycle);
      if (lossHistory.length > LOSS_HISTORY_SIZE) lossHistory.shift();

      // 정확한 레이턴시 계산:
      // 1. 송출자→서버 레이턴시 (broadcasterLatency): 서버에서 측정
      // 2. 서버→뷰어 레이턴시: (now - serverSendTime) 또는 RTT/2로 추정
      const serverToViewerLatency = serverRtt > 0 ? Math.round(serverRtt / 2) : 0;
      const totalLatency = data.broadcasterLatency + serverToViewerLatency;

      totalFrames++;
      totalBytes += data.frameSize;
      bitrateBytes += data.frameSize;

      // 1초마다 비트레이트 계산
      const bitrateElapsed = (now - lastBitrateTime) / 1000;
      if (bitrateElapsed >= 1) {
        currentBitrate = (bitrateBytes * 8) / bitrateElapsed / 1000000; // Mbps
        document.getElementById('bitrate').textContent = currentBitrate.toFixed(2) + ' Mbps';
        statsData.bitrate.push(currentBitrate);
        if (statsData.bitrate.length > MAX_POINTS) statsData.bitrate.shift();
        bitrateBytes = 0;
        lastBitrateTime = now;
      }

      // FPS 업데이트 및 색상
      const fpsEl = document.getElementById('fps');
      fpsEl.textContent = data.fps.toFixed(1) + ' fps';
      updateFpsStatusColor('fps', data.fps, expectedFps);

      // Latency 업데이트 및 색상 (50ms 이하: 좋음, 100ms 이하: 경고, 그 이상: 위험)
      const latencyEl = document.getElementById('latency');
      latencyEl.textContent = totalLatency + ' ms';
      updateStatusColor('latency', totalLatency, { good: 50, warning: 100 });

      // 패킷 로스 표시
      const lossEl = document.getElementById('packetLoss');
      lossEl.textContent = lossRate.toFixed(1) + '%';
      updateStatusColor('packetLoss', lossRate, { good: 5, warning: 15 });

      document.getElementById('frameSize').textContent = (data.frameSize / 1024).toFixed(1) + ' KB';
      document.getElementById('framesReceived').textContent = mySent.toLocaleString();
      document.getElementById('bytesReceived').textContent = formatBytes(totalBytes);
      document.getElementById('framesLost').textContent = myDropped.toLocaleString();

      // labels도 함께 추가 (broadcast-stats가 없을 때 대비)
      if (statsData.labels.length < statsData.latency.length + 1) {
        statsData.labels.push('');
      }

      statsData.latency.push(totalLatency);
      statsData.fps.push(data.fps);
      statsData.frameSize.push(data.frameSize / 1024);
      // 로스 그래프: 이번 구간 드랍 수 표시 (더 직관적)
      const recentDrops = lossHistory.reduce((a, b) => a + b, 0);
      statsData.loss.push(droppedThisCycle);

      // 차트 색상 업데이트
      updateChartColor(charts.latency, totalLatency, { good: 50, warning: 100 }, true);
      updateChartColor(charts.fps, data.fps, { good: expectedFps * 0.9, warning: expectedFps * 0.7 }, false);
      updateChartColor(charts.loss, droppedThisCycle, { good: 0, warning: 1 }, true); // 0이면 초록, 1이상이면 빨강
      updateChartColor(charts.rtt, serverRtt, { good: 20, warning: 50 }, true);

      if (statsData.latency.length > MAX_POINTS) {
        statsData.labels.shift();
        statsData.latency.shift();
        statsData.fps.shift();
        statsData.frameSize.shift();
        statsData.loss.shift();
      }

      updateCharts();
    });

    // Bitrate from broadcaster (FPS 정보만 사용)
    socket.on('broadcast-stats', (data) => {
      // 송출자의 실제 FPS로 예상 FPS 업데이트
      if (data.fps && data.fps > 0) {
        expectedFps = Math.round(data.fps);
      }
    });

    // Global stats (MJPEG 연결 전 또는 폴링 모드용)
    socket.on('frame-stats-global', (data) => {
      // 개별 stats를 받지 못한 경우에만 사용
      if (myDropped === 0 && mySent === 0) {
        lastFrameTime = Date.now();
        // 기본 정보만 업데이트
        if (data.fps) {
          document.getElementById('fps').textContent = data.fps.toFixed(1) + ' fps';
        }
        if (data.frameSize) {
          document.getElementById('frameSize').textContent = (data.frameSize / 1024).toFixed(1) + ' KB';
        }
      }
    });

    function formatBytes(b) {
      if (b >= 1073741824) return (b / 1073741824).toFixed(2) + ' GB';
      if (b >= 1048576) return (b / 1048576).toFixed(2) + ' MB';
      if (b >= 1024) return (b / 1024).toFixed(2) + ' KB';
      return b + ' B';
    }
  </script>
</body>
</html>
